
Sub ListAndExportProcedure( _
                            Optional ProcedureName As String, _
                            Optional FromWorkbook As Workbook)
Rem @star
'#INCLUDE FollowLink
'#INCLUDE FileExists
'#INCLUDE AddListOfLinkedProceduresToProcedure
'#INCLUDE TxtOverwrite
'#INCLUDE ExportProcedure
'#INCLUDE LinkedProcs
'#INCLUDE TxtRead
'#INCLUDE ProceduresOfWorkbook
'#INCLUDE ProcedureExists
'#INCLUDE ActiveCodepaneWorkbook
'#INCLUDE ActiveProcName
'#INCLUDE ListContainedProceduresInTXT
'#INCLUDE dp
'#INCLUDE CollectionContains

''''''''''''''''''''''''''''''''''''''''''''
''DEVELOPER  Anastasiou Alex
''EMAIL      AnastasiouAlex@gmail.com
''GITHUB     https://github.com/AlexOfRhodes
''YOUTUBE    https://bit.ly/3aLZU9M
''''''''''''''''''''''''''''''''''''''''''''

    If ProcedureName = "" Then ProcedureName = ActiveProcName
    If FromWorkbook Is Nothing Then Set FromWorkbook = ActiveCodepaneWorkbook
    

    If ProcedureExists(ProcedureName, FromWorkbook) = False Then
        MsgBox ProcedureName & " not found in workbook " & FromWorkbook.Name
    End If
    
    AddListOfLinkedProceduresToProcedure CStr(ProcedureName), ProceduresOfWorkbook(FromWorkbook), FromWorkbook
    
    Dim ExportedProcedures As New Collection
    Dim Proccessed As New Collection
    
    On Error Resume Next
    
    ExportProcedure ProcedureName
    ExportedProcedures.Add CStr(ProcedureName), CStr(ProcedureName)
    
    For Each PROCEDURE In LinkedProcs(ProcedureName, FromWorkbook)
        AddListOfLinkedProceduresToProcedure CStr(PROCEDURE), ProceduresOfWorkbook(FromWorkbook), FromWorkbook
        ExportProcedure CStr(PROCEDURE), FromWorkbook
        ExportedProcedures.Add CStr(PROCEDURE), CStr(PROCEDURE)
    Next
    
    'test
    Dim ProceduresCount As Long
    ProceduresCount = ExportedProcedures.count
retry:
    For Each PROCEDURE In ExportedProcedures
        For Each ELEMENT In LinkedProcs(PROCEDURE, FromWorkbook)
            If Not CollectionContains(ExportedProcedures, , ELEMENT) Then
                AddListOfLinkedProceduresToProcedure CStr(ELEMENT), ProceduresOfWorkbook(FromWorkbook), FromWorkbook
                ExportedProcedures.Add CStr(ELEMENT), CStr(ELEMENT)
            End If
        Next
    Next
    If ExportedProcedures.count > ProceduresCount Then
        ProceduresCount = ExportedProcedures.count
        GoTo retry
    End If
    On Error GoTo 0
    'end test
            
        If ExportedProcedures.count > 1 Then
            Dim MergedName As String
            Dim procFile As String
                MergedName = "Merged_" & ProcedureName
                Dim MergedString As String
                For Each PROCEDURE In ExportedProcedures
                    procFile = SNIP_FOLDER & CStr(PROCEDURE) & ".txt"
                    MergedString = IIf(MergedString = "", TxtRead(procFile), MergedString & vbNewLine & TxtRead(procFile))
                Next
                TxtOverwrite SNIP_FOLDER & MergedName & ".txt", MergedString
                ListContainedProceduresInTXT SNIP_FOLDER & MergedName & ".txt"
        End If
        FollowLink SNIP_FOLDER
End Sub

Function FileExists(ByVal strFile As String, Optional bFindFolders As Boolean) As Boolean
    Dim lngAttributes As Long
    lngAttributes = (vbReadOnly Or vbHidden Or vbSystem)
    If bFindFolders Then
        lngAttributes = (lngAttributes Or vbDirectory)
    Else
        Do While Right$(strFile, 1) = "\"
            strFile = Left$(strFile, Len(strFile) - 1)
        Loop
    End If
    On Error Resume Next
    FileExists = (Len(Dir(strFile, lngAttributes)) > 0)
End Function

Sub AddListOfLinkedProceduresToProcedure(ProcedureName As String, procedures As Collection, FromWorkbook As Workbook)
'#INCLUDE RegexTest
'#INCLUDE ProcedureFirstLine
'#INCLUDE GetProcText
'#INCLUDE ModuleOfProcedure
    Dim ListOfImports As String
    Dim Module As VBComponent:  Set Module = ModuleOfProcedure(FromWorkbook, ProcedureName)
    Dim ProcedureText As String:    ProcedureText = GetProcText(Module, ProcedureName)
    Dim PROCEDURE As Variant
    For Each PROCEDURE In procedures
        If UCase(CStr(PROCEDURE)) <> UCase(CStr(ProcedureName)) Then
            If InStr(1, ProcedureText, CStr(PROCEDURE)) > 0 Then
                Rem If RegexTest(ProcedureText, "\W" & Procedure & "[.(\W]", , True) Then
                If InStr(1, ProcedureText, "#INCLUDE " & PROCEDURE) = 0 And InStr(1, ListOfImports, "#INCLUDE " & PROCEDURE) = 0 Then
                    If ListOfImports = "" Then
                        ListOfImports = "'#INCLUDE " & PROCEDURE
                    Else
                        ListOfImports = ListOfImports & vbNewLine & "'#INCLUDE " & PROCEDURE
                    End If
                End If
            End If
        End If
    Next
    If ListOfImports <> "" Then Module.CodeModule.InsertLines ProcedureFirstLine(Module, ProcedureName), ListOfImports
End Sub

Function TxtOverwrite(sFile As String, sText As String)
    On Error GoTo Err_Handler
    Dim FileNumber As Integer
    FileNumber = FreeFile
    Open sFile For Output As #FileNumber
    Print #FileNumber, sText
    Close #FileNumber
Exit_Err_Handler:
    Exit Function
Err_Handler:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
           "Error Number: " & err.Number & vbCrLf & _
           "Error Source: TxtOverwrite" & vbCrLf & _
           "Error Description: " & err.Description, vbCritical, "An Error has Occurred!"
    GoTo Exit_Err_Handler
End Function

Sub ExportProcedure( _
                    Optional ProcedureName As String, _
                    Optional FromWorkbook As Workbook)
'#INCLUDE FileExists
'#INCLUDE TxtOverwrite
'#INCLUDE LinkedProcs
'#INCLUDE ActiveCodepaneWorkbook
'#INCLUDE ActiveProcName
'#INCLUDE GetProcText
'#INCLUDE ModuleOfProcedure
'#INCLUDE FileLastModified
'#INCLUDE dp
    
    
    
    If ProcedureName = "" Then ProcedureName = ActiveProcName
    If FromWorkbook Is Nothing Then Set FromWorkbook = ActiveCodepaneWorkbook
    Dim procedures As Collection: Set procedures = LinkedProcs(ProcedureName, FromWorkbook)
    On Error Resume Next
    procedures.Add ProcedureName, ProcedureName
    On Error GoTo 0
    Dim PROCEDURE As Variant
    Dim FileFullName As String
    Dim lastMod As Date
    Dim timeDif As Long
    
    For Each PROCEDURE In procedures
        FileFullName = SNIP_FOLDER & PROCEDURE & ".txt"

        If FileExists(FileFullName) = False Then
            Debug.Print IIf(FileExists(FileFullName) = False, "NEW ", "OVERWROTE ") & PROCEDURE
            TxtOverwrite FileFullName, GetProcText(ModuleOfProcedure(FromWorkbook, CStr(PROCEDURE)), CStr(PROCEDURE))
        Else
            On Error Resume Next
            lastMod = FileLastModified(FileFullName)
            timeDif = Second((Now() - lastMod)) '(Minute(Now) * 60) + Second(Now) - (Minute(lastMod) * 60) - Second(lastMod)
            On Error GoTo 0
            If timeDif > 60 Then
                Debug.Print IIf(FileExists(FileFullName) = False, "NEW ", "OVERWROTE ") & PROCEDURE
                TxtOverwrite FileFullName, GetProcText(ModuleOfProcedure(FromWorkbook, CStr(PROCEDURE)), CStr(PROCEDURE))
            End If
        End If
    Next
    
End Sub

Function LinkedProcs( _
         ProcedureName As Variant, _
         FromWorkbook As Workbook) As Collection
    Rem dp LinkedProcs("FindIfGetRow",thisworkbook)
'#INCLUDE GetCallsOfProcedure
'#INCLUDE ProceduresOfWorkbook
'#INCLUDE ModuleOfProcedure
'#INCLUDE dp
'#INCLUDE CollectionContains
    Dim AllProcedures As Collection:       Set AllProcedures = ProceduresOfWorkbook(FromWorkbook)
    Dim Proccessed As Collection:          Set Proccessed = New Collection
    Dim CalledProcedures As Collection:    Set CalledProcedures = New Collection
        GetCallsOfProcedure ModuleOfProcedure(FromWorkbook, ProcedureName), ProcedureName, AllProcedures, CalledProcedures
    Dim CalledProceduresCount As Long:    CalledProceduresCount = CalledProcedures.count
    Dim PROCEDURE As Variant
    Dim Module As VBComponent
REPEAT:
    
    For Each PROCEDURE In CalledProcedures
            
        If Not CollectionContains(Proccessed, , CStr(PROCEDURE)) Then
            Proccessed.Add PROCEDURE, CStr(PROCEDURE)
            Set Module = ModuleOfProcedure(FromWorkbook, ProcedureName)
            GetCallsOfProcedure Module, CStr(PROCEDURE), AllProcedures, CalledProcedures
        End If
    Next
    If CalledProcedures.count > CalledProceduresCount Then
        CalledProceduresCount = CalledProcedures.count
        GoTo REPEAT
    End If
    Set LinkedProcs = CalledProcedures
End Function

Function TxtRead(sPath As String) As String
'#INCLUDE FileExists
    If FileExists(sPath) = False Then
        MsgBox "File was not found."
        Exit Function
    End If
    Open sPath For Input As #1
    Do Until EOF(1)
        Line Input #1, sTXT
        TxtRead = TxtRead & sTXT & vbLf
    Loop
    Close
    If Len(TxtRead) = 0 Then
        TxtRead = ""
    Else
        TxtRead = Left(TxtRead, Len(TxtRead) - 1)
    End If
End Function



Function ProceduresOfWorkbook(TargetWorkbook As Workbook) As Collection
    Dim Module As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim lineNum As Long
    Dim coll As New Collection
    Dim ProcedureName As String
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If Module.Type <> vbext_ct_ClassModule Then
            With Module.CodeModule
                lineNum = .CountOfDeclarationLines + 1
                Do Until lineNum >= .CountOfLines
                    ProcedureName = .ProcOfLine(lineNum, ProcKind)
                    If InStr(1, ProcedureName, "_") = 0 Then coll.Add ProcedureName
                    lineNum = .ProcStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
                Loop
            End With
        End If
    Next
    Set ProceduresOfWorkbook = coll
End Function

Function ProcedureExists( _
         ProcedureName As Variant, _
         FromWorkbook As Workbook) _
        As Boolean
'#INCLUDE ProceduresOfWorkbook
    Dim AllProcedures As Collection: Set AllProcedures = ProceduresOfWorkbook(FromWorkbook)
    Dim PROCEDURE As Variant
    For Each PROCEDURE In AllProcedures
        If UCase(CStr(PROCEDURE)) = UCase(ProcedureName) Then
            ProcedureExists = True
            Exit Function
        End If
    Next
End Function

Public Function ActiveCodepaneWorkbook() As Workbook
    Dim TmpStr As String
    TmpStr = Application.VBE.SelectedVBComponent.Collection.Parent.FileName
    TmpStr = Right(TmpStr, Len(TmpStr) - InStrRev(TmpStr, "\"))
    Set ActiveCodepaneWorkbook = Workbooks(TmpStr)
End Function

Public Function ActiveProcName() As String
    Application.VBE.ActiveCodePane.GetSelection L1&, C1&, L2&, C2&
    ActiveProcName = Application.VBE.ActiveCodePane _
                     .CodeModule.ProcOfLine(L1&, vbext_pk_Proc)
End Function

Sub ListContainedProceduresInTXT(FileName As String)
'#INCLUDE ProceduresOfTXT
'#INCLUDE TxtOverwrite
'#INCLUDE TxtRead
    Dim v As Variant: v = ProceduresOfTXT(FileName, True)
    If TypeName(v) = "Empty" Then Exit Sub
    Dim s As String: s = TxtRead(FileName)
    Dim line As String: line = String(30, "'")
    TxtOverwrite FileName, _
    line & vbNewLine & _
    "'Contains the following procedures " & "#" & UBound(v) + 1 & vbNewLine & line & vbNewLine & "'" & _
    Join(v, vbNewLine & "'") & vbNewLine & vbNewLine & s
End Sub

Sub FollowLink(FolderPath As String)
On Error Resume Next
    Dim oShell As Object
    Dim Wnd As Object
    Set oShell = CreateObject("Shell.Application")
    For Each Wnd In oShell.Windows
        If Wnd.Name = "File Explorer" Then
            If Wnd.Document.Folder.Self.path = FolderPath Then Exit Sub
        End If
    Next Wnd
    Application.ThisWorkbook.FollowHyperlink Address:=FolderPath, NewWindow:=True
End Sub

Sub dp(var As Variant)
'#INCLUDE DPH
'#INCLUDE ArrayDimensions
    Dim ELEMENT As Variant
    Select Case TypeName(var)
        Case Is = "String", "Long", "Integer", "Boolean"
            Debug.Print var
            Rem todo How to handle multidimensional array?
        Case Is = "Variant()", "String()", "Long()", "Integer()"
            If ArrayDimensions(var) = 1 Then
                Dim i As Long
                For i = LBound(var) To UBound(var)
                    Debug.Print var(i)
                Next i
            ElseIf ArrayDimensions(var) > 1 Then
                DPH var
            End If
        Case Is = "Collection"
            For Each ELEMENT In var
                dp ELEMENT
            Next ELEMENT
        Case Is = "Range"
            dp var.Value
        Case Is = "Date"
            Debug.Print var
        Case Else
    End Select
End Sub

Public Function CollectionContains(Kollection As Collection, Optional Key As Variant, Optional Item As Variant) As Boolean
    Dim strKey As String
    Dim var As Variant
    If Not IsMissing(Key) Then
        strKey = CStr(Key)
        On Error Resume Next
        CollectionContains = True
        var = Kollection(strKey)
        If err.Number = 91 Then GoTo CheckForObject
        If err.Number = 5 Then GoTo NotFound
        On Error GoTo 0
        Exit Function
CheckForObject:
        If IsObject(Kollection(strKey)) Then
            CollectionContains = True
            On Error GoTo 0
            Exit Function
        End If
NotFound:
        CollectionContains = False
        On Error GoTo 0
        Exit Function
    ElseIf Not IsMissing(Item) Then
        CollectionContains = False
        For Each var In Kollection
            If var = Item Then
                CollectionContains = True
                Exit Function
            End If
        Next var
    Else
        CollectionContains = False
    End If
End Function

Public Function RegexTest( _
       ByVal string1 As String, _
       ByVal stringPattern As String, _
       Optional ByVal globalFlag As Boolean, _
       Optional ByVal ignoreCaseFlag As Boolean, _
       Optional ByVal multilineFlag As Boolean) _
        As Boolean
    Dim Regex As Object
    Set Regex = CreateObject("VBScript.RegExp")
    With Regex
        .Global = globalFlag
        .IgnoreCase = ignoreCaseFlag
        .MultiLine = multilineFlag
        .Pattern = stringPattern
    End With
    RegexTest = Regex.test(string1)
End Function

Function ProcedureFirstLine(Module As VBComponent, procname As String) As Long
'#INCLUDE InStrExact
    Dim N As Long
    Dim s As String
    Dim ProcKind As VBIDE.vbext_ProcKind
    For N = Module.CodeModule.ProcBodyLine(procname, ProcKind) + IIf(N = 0, 1, 0) To Module.CodeModule.CountOfLines
        s = Trim(Module.CodeModule.Lines(N, 1))
        If s = vbNullString Then
            Exit For
        ElseIf Left(s, 1) = "'" Then
        ElseIf Left(s, 3) = "Rem" Then
        ElseIf Right(Trim(Module.CodeModule.Lines(N - 1, 1)), 1) = "_" Then
        ElseIf Right(s, 1) = "_" Then
        ElseIf InStrExact(1, s, "Sub ") Then
        ElseIf InStrExact(1, s, "Function ") Then
        Else
            Exit For
        End If
    Next N
    ProcedureFirstLine = N
End Function

Public Function GetProcText(vbComp As VBComponent, _
                            sProcName As Variant, _
                            Optional bInclHeader As Boolean = True) As String
    If vbComp Is Nothing Then
        'sProcName not found
        Stop
    End If
    Dim codeMod As CodeModule
    Set codeMod = vbComp.CodeModule
    Dim lProcStart            As Long
    Dim lProcBodyStart        As Long
    Dim lProcNoLines          As Long
    Const vbext_pk_Proc = 0
    On Error GoTo Error_Handler
    lProcStart = codeMod.ProcStartLine(sProcName, vbext_pk_Proc)
    lProcBodyStart = codeMod.ProcBodyLine(sProcName, vbext_pk_Proc)
    lProcNoLines = codeMod.ProcCountLines(sProcName, vbext_pk_Proc)
    If bInclHeader = True Then
        GetProcText = codeMod.Lines(lProcStart, lProcNoLines)
    Else
        lProcNoLines = lProcNoLines - (lProcBodyStart - lProcStart)
        GetProcText = codeMod.Lines(lProcBodyStart, lProcNoLines)
    End If
Error_Handler_Exit:
    On Error Resume Next
    Exit Function
Error_Handler:
    Rem debug.Print _
    "Error Source: GetProcText" & vbCrLf & _
    "Error Description: " & err.Description & _
    Switch(Erl = 0, vbNullString, Erl <> 0, vbCrLf & "Line No: " & Erl)
    Resume Error_Handler_Exit
End Function

Function ModuleOfProcedure(wb As Workbook, ProcedureName As Variant) As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim lineNum As Long, NumProc As Long
    Dim procname As String
    Dim vbComp As VBComponent
    For Each vbComp In wb.VBProject.VBComponents
        With vbComp.CodeModule
            lineNum = .CountOfDeclarationLines + 1
            Do Until lineNum >= .CountOfLines
                procname = .ProcOfLine(lineNum, ProcKind)
                lineNum = .ProcStartLine(procname, ProcKind) + .ProcCountLines(procname, ProcKind) + 1
                If UCase(procname) = UCase(ProcedureName) Then
                    Set ModuleOfProcedure = vbComp
                    Exit Function
                End If
            Loop
        End With
    Next vbComp
End Function

Function FileLastModified(FilePath) As Date
    Dim fs, f
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFile(FilePath)
    FileLastModified = f.DateLastModified
End Function


Sub GetCallsOfProcedure( _
                        Module As VBComponent, _
                        ProcedureName As Variant, _
                        AllProcedures As Collection, _
                        ByRef OutputCollection As Collection)
'#INCLUDE ArrayTrim
'#INCLUDE GetProcText
'#INCLUDE InStrExact
    
    Dim Code As String: Code = GetProcText(Module, ProcedureName)
    Dim CodeLines As Variant
    Dim PROCEDURE As Variant
    Dim CodeLine As Variant
    For Each PROCEDURE In AllProcedures
        If CStr(PROCEDURE) <> ProcedureName Then
            If InStr(1, Code, CStr(PROCEDURE)) > 0 Then
                CodeLines = Split(Code, vbNewLine)
                ArrayTrim CodeLines
                For Each CodeLine In CodeLines
                    If InStrExact(1, CStr(CodeLine), CStr(PROCEDURE), True) > 0 Then
                        On Error Resume Next
                        OutputCollection.Add CStr(PROCEDURE), CStr(PROCEDURE)
                        On Error GoTo 0
                        Exit For
                    End If
                Next
            End If
        End If
    Next PROCEDURE
End Sub




Sub ArrayTrim(arr As Variant)
    Dim i As Long
    For i = LBound(arr) To UBound(arr)
        If TypeName(arr(i)) = "String" Then arr(i) = Trim(arr(i))
    Next
End Sub

Function InStrExact(Start As Long, SourceText As String, WordToFind As String, _
                    Optional CaseSensitive As Boolean = False, _
                    Optional AllowAccentedCharacters As Boolean = False) As Long
    Dim x As Long, Str1 As String, Str2 As String, Pattern As String
    Const UpperAccentsOnly As String = "ÇÉÑ"
    Const UpperAndLowerAccents As String = "ÇÉÑçéñ"
    If CaseSensitive Then
        Str1 = SourceText
        Str2 = WordToFind
        Pattern = "[!A-Za-z0-9]"
        If AllowAccentedCharacters Then Pattern = Replace(Pattern, "!", "!" & UpperAndLowerAccents)
    Else
        Str1 = UCase(SourceText)
        Str2 = UCase(WordToFind)
        Pattern = "[!A-Z0-9]"
        If AllowAccentedCharacters Then Pattern = Replace(Pattern, "!", "!" & UpperAccentsOnly)
    End If
    For x = Start To Len(Str1) - Len(Str2) + 1
        If Mid(" " & Str1 & " ", x, Len(Str2) + 2) Like Pattern & Str2 & Pattern _
                                                   And Not Mid(Str1, x) Like Str2 & "'[" & Mid(Pattern, 3) & "*" Then
            InStrExact = x
            Exit Function
        End If
    Next
End Function


Function ProceduresOfTXT(FilePath As Variant, Optional NameOnly As Boolean) As Variant
'#INCLUDE joinArrays
'#INCLUDE SortArray
'#INCLUDE TxtRead
    Dim var
    var = Split(TxtRead(CStr(FilePath)), Chr(10))
    Dim out
    out = joinArrays(Filter(var, "Sub "), Filter(var, "Function "))
    If TypeName(out) = "Empty" Then Exit Function
    out = Filter(out, "(", True)
    out = Filter(out, "Declare", False)
    If NameOnly = True Then
        Dim i As Long
        For i = LBound(out) To UBound(out)
'            If InStr(out(i), "(") <> 0 Then
                out(i) = Left(out(i), InStr(1, out(i), "(") - 1)
                out(i) = Replace(out(i), "Private ", "")
                out(i) = Replace(out(i), "Public ", "")
                out(i) = Replace(out(i), "Sub ", "")
                out(i) = Replace(out(i), "Function ", "")
'            End If
        Next
    End If
    SortArray out
    ProceduresOfTXT = out
    Rem ProceduresOfTXT = Join(out, Chr(10))
End Function

Public Sub SortArray(vArray As Variant, inLow As Long, inHi As Long)
    Dim tmpSwap As Variant
    Dim tmpLow  As Long:    tmpLow = inLow
    Dim tmpHi   As Long:      tmpHi = inHi
    Dim pivot   As Variant:    pivot = vArray((inLow + inHi) \ 2)
    While (tmpLow <= tmpHi)
        While (vArray(tmpLow) < pivot And tmpLow < inHi)
            tmpLow = tmpLow + 1
        Wend
        While (pivot < vArray(tmpHi) And tmpHi > inLow)
            tmpHi = tmpHi - 1
        Wend
        If (tmpLow <= tmpHi) Then
            tmpSwap = vArray(tmpLow)
            vArray(tmpLow) = vArray(tmpHi)
            vArray(tmpHi) = tmpSwap
            tmpLow = tmpLow + 1
            tmpHi = tmpHi - 1
        End If
    Wend
    If (inLow < tmpHi) Then SortArray vArray, inLow, tmpHi
    If (tmpLow < inHi) Then SortArray vArray, tmpLow, inHi
End Sub

Function joinArrays(arr1 As Variant, arr2 As Variant) As Variant
    Dim arrToReturn() As Variant, myCollection As New Collection
    For Each x In arr1: myCollection.Add x: Next
    For Each y In arr2: myCollection.Add y: Next
    If myCollection.count = 0 Then
        joinArrays = Array("")
        Exit Function
    End If
    ReDim arrToReturn(1 To myCollection.count)
    For i = 1 To myCollection.count: arrToReturn(i) = myCollection.Item(i): Next
    joinArrays = arrToReturn
End Function

Sub DPH(ByVal Hairetu, Optional HyoujiMaxNagasa%, Optional HairetuName$)
'#INCLUDE DebugPrintHairetu
    Call DebugPrintHairetu(Hairetu, HyoujiMaxNagasa, HairetuName)
End Sub

Function ArrayDimensions(ByVal vArray As Variant) As Long
    Dim dimnum As Long
    On Error GoTo FinalDimension
    For dimnum = 1 To 60000
        ErrorCheck = LBound(vArray, dimnum)
    Next
FinalDimension:
    ArrayDimensions = dimnum - 1
End Function

Rem ------------------------


Sub DebugPrintHairetu(ByVal Hairetu, Optional HyoujiMaxNagasa%, Optional HairetuName$)
'#INCLUDE ShortenToByteCharacters
    Dim i&, j&, k&, m&, N&
    Dim TateMin&, TateMax&, YokoMin&, YokoMax&
    Dim WithTableHairetu
    Dim NagasaList, MaxNagasaList
    Dim NagasaOnajiList
    Dim OutputList
    Const SikiriMoji$ = "|"
    Dim Jigen2%
    On Error Resume Next
    Jigen2 = UBound(Hairetu, 2)
    On Error GoTo 0
    If Jigen2 = 0 Then
        Hairetu = Application.Transpose(Hairetu)
    End If
    TateMin = LBound(Hairetu, 1)
    TateMax = UBound(Hairetu, 1)
    YokoMin = LBound(Hairetu, 2)
    YokoMax = UBound(Hairetu, 2)
    ReDim WithTableHairetu(1 To TateMax - TateMin + 1 + 1, 1 To YokoMax - YokoMin + 1 + 1)
    For i = 1 To TateMax - TateMin + 1
        WithTableHairetu(i + 1, 1) = TateMin + i - 1
            For j = 1 To YokoMax - YokoMin + 1
                WithTableHairetu(1, j + 1) = YokoMin + j - 1
                    WithTableHairetu(i + 1, j + 1) = Hairetu(i - 1 + TateMin, j - 1 + YokoMin)
                    Next j
                Next i
                N = UBound(WithTableHairetu, 1)
                m = UBound(WithTableHairetu, 2)
                ReDim NagasaList(1 To N, 1 To m)
                ReDim MaxNagasaList(1 To m)
                Dim TmpStr$
                For j = 1 To m
                    For i = 1 To N
                        If j > 1 And HyoujiMaxNagasa <> 0 Then
                            TmpStr = WithTableHairetu(i, j)
                            WithTableHairetu(i, j) = ShortenToByteCharacters(TmpStr, HyoujiMaxNagasa)
                            End If
                            NagasaList(i, j) = LenB(StrConv(WithTableHairetu(i, j), vbFromUnicode))
                            MaxNagasaList(j) = WorksheetFunction.Max(MaxNagasaList(j), NagasaList(i, j))
                        Next i
                    Next j
                    ReDim NagasaOnajiList(1 To N, 1 To m)
                    Dim TmpMaxNagasa&
                    For j = 1 To m
                        TmpMaxNagasa = MaxNagasaList(j)
                        For i = 1 To N
                            NagasaOnajiList(i, j) = WithTableHairetu(i, j) & WorksheetFunction.Rept(" ", TmpMaxNagasa - NagasaList(i, j))
                        Next i
                    Next j
                    ReDim OutputList(1 To N)
                    For i = 1 To N
                        For j = 1 To m
                            If j = 1 Then
                                OutputList(i) = NagasaOnajiList(i, j)
                            Else
                                OutputList(i) = OutputList(i) & SikiriMoji & NagasaOnajiList(i, j)
                            End If
                        Next j
                    Next i
                    Debug.Print HairetuName
                    For i = 1 To N
                        Debug.Print OutputList(i)
                    Next i
                End Sub

Function ShortenToByteCharacters(Mojiretu$, ByteNum%)
'#INCLUDE CalculateByteCharacters
'#INCLUDE TextDecomposition
    Dim OriginByte%
    Dim Output
    OriginByte = LenB(StrConv(Mojiretu, vbFromUnicode))
    If OriginByte <= ByteNum Then
        Output = Mojiretu
    Else
        Dim RuikeiByteList, BunkaiMojiretu
        RuikeiByteList = CalculateByteCharacters(Mojiretu)
        BunkaiMojiretu = TextDecomposition(Mojiretu)
        Dim AddMoji$
        AddMoji = "."
        Dim i&, N&
        N = Len(Mojiretu)
        For i = 1 To N
            If RuikeiByteList(i) < ByteNum Then
                Output = Output & BunkaiMojiretu(i)
            ElseIf RuikeiByteList(i) = ByteNum Then
                If LenB(StrConv(BunkaiMojiretu(i), vbFromUnicode)) = 1 Then
                    Output = Output & AddMoji
                Else
                    Output = Output & AddMoji & AddMoji
                End If
                Exit For
            ElseIf RuikeiByteList(i) > ByteNum Then
                Output = Output & AddMoji
                Exit For
            End If
        Next i
    End If
    ShortenToByteCharacters = Output
End Function

Function CalculateByteCharacters(Mojiretu$)
    Dim MojiKosu%
    MojiKosu = Len(Mojiretu)
    Dim Output
    ReDim Output(1 To MojiKosu)
    Dim i&
    Dim TmpMoji$
    For i = 1 To MojiKosu
        TmpMoji = Mid(Mojiretu, i, 1)
        If i = 1 Then
            Output(i) = LenB(StrConv(TmpMoji, vbFromUnicode))
        Else
            Output(i) = LenB(StrConv(TmpMoji, vbFromUnicode)) + Output(i - 1)
        End If
    Next i
    CalculateByteCharacters = Output
End Function

Function TextDecomposition(Mojiretu$)
    Dim i&, N&
    Dim Output
    N = Len(Mojiretu)
    ReDim Output(1 To N)
    For i = 1 To N
        Output(i) = Mid(Mojiretu, i, 1)
    Next i
    TextDecomposition = Output
End Function
